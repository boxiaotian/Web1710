<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
</html>


<script>

//// 构造函数中
//function Dog() {
//}
//
//// 在原型对象中新增 属性  name
//Dog.prototype.name = "小黄"
////Dog.prototype = {name: "小黄"}
//// 新增方法 bark
//Dog.prototype.bark = function() {
//	console.log("汪汪汪~")
//}
//
//var dog = new Dog()
//
////  dog.name  代表寻找 dog 对象中的 name 属性值
////        1. dog 中找name
////        2. 在 Dog 的原型对象中找
//console.log( dog.name )  // 小黄
////  dog.bark  代表寻找 dog 对象中的 bark 
////        1. dog 中找 bark   (找不到)
////        2. 在 Dog 的原型对象中找 (找到了)
//dog.bark()
//
//// 所有构造函数中都存在 原型  prototype  对象！
////Dog.prototype
//
////console.log( Dog.prototype )   // Object


//function Dog() {
//}
//
//Dog.prototype.bark = function() {
//	console.log("汪汪汪~")
//}
//
//var dog1 = new Dog()
//var dog2 = new Dog()
//
//dog1.bark()
//dog2.bark()
//
//// true     原型用来解决函数空间地址不一样的问题，这两个地址一样
//console.log( dog1.bark == dog2.bark )
////  【建议】 所有对象中的方法，都建议放在 原型对象中，这样节约空间




//
//function Dog() {
//}
//
//// 构造函数      构造函数写的
////console.log(Dog.prototype.constructor == Dog)
//
//var dog = new Dog()
//
//// undefined   1. 自己中没有   2. 原型中也没有   ==> undefined
////  【注意】 prototype 是与 构造函数名一起的，千万不要用对象来访问它
//// console.log( dog.prototype )
//
//// dog.__proto__ 就是原型对象
//console.log( dog.__proto__ === Dog.prototype)  // true
//
//
//
//
//function Dog() {
//}
//
//Dog.prototype.name = "小黄"
//
//var dog1 = new Dog()
//var dog2 = new Dog()
//
////console.log( dog1.name ) 
//
////Dog.prototype.name = "小红"
////console.log( dog2.name )  // 小红
//
//dog1.__proto__.name = "小红"
//console.log( dog2.name )  // 小红







function Dog() {
}

function Cat() {
}

var dog = new Dog()
var cat = new Cat()

//  instanceof  运算符
console.log(   dog instanceof Dog )	   // true
console.log(   dog instanceof Cat )    // false

//  isPrototypeOf  函数
//console.log(   Dog.prototype.isPrototypeOf(dog)  )	 // true
//console.log(   Cat.prototype.isPrototypeOf(dog)  )   // false

</script>
